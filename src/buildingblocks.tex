\section{The Solution: Common Building Blocks}\label{buildings-blocks}

The two problems detailed above are side effects of the relentless march of
progress. The traditional approach for building workflow systems has been to
build as much of the required capability as possible into the system itself,
relying very little on external services or even third party code to address
pressing issues in one or more domains. However, history has shown that
important high-level functionality slowly moves down the software stack and
into kernels, kernel services, and system libraries. Is it better at that
point to use an existing system that requires significant time and resources
to learn, or to develop yet another workflow management system with common
tools, implementing only the gaps instead?

The answer to this question is complicated by the fact that workflows
themselves have evolved. First, contemporary workflows are often the
representation of methodological advances and may be more pervasive,  short-
lived, and wide-ranging than traditional workflows. Further, they are no longer
confined to ``big science'' projects because sophisticated workflows are needed
by many types of scientific projects, which leads to diverse design features and thus
makes it unlikely that one model will be universally applicable.  The ability to prototype, test
and experiment with workflows at scale suggests a need for interfaces and
middleware services that enable the rapid development of resources. The
challenge is to provide these capabilities along with considerations of
usability and extensibility.

Jha and Turilli discuss this trend as it relates to workflows from a 
cyber-infrastructure perspective and to existing large-scale scientific workflow
efforts \cite{jha_building_2016}. They propose that, while historically
successful, monolithic workflow systems present many problems for users,
developers, and maintainers. Instead, they propose that a new ``Lego-style''
approach might work better where individual building blocks of capability
are assembled into the final workflow management system, subsystem, or
product.

More formally, a building block is a collection of functionality commonly
identified across existing workflow systems that behaves like a logically and
uniformly addressable service. Table \ref{blocks} lists six common types of
functionality that are readily observed in workflow management systems. There
are certainly additional types of functionality that are common, but for
pedagogical reasons we limit the list to the most obvious choices in a quick review of the literature previously cited.

\begin{table*}[h]
\begin{tabu} to \textwidth {|X[l]|X[l]|} \hline
\textbf{Functionality} & \textbf{Description} \tabularnewline\hline Data and
metadata management & Management of data, metadata, and general file input and
output activities whether for internal tracking or external user
consumption. \\ \hline 
Workflow execution engine & The primary
actor that manages the execution of the activities as provided by the workflow
description. \tabularnewline\hline 
Resource management and acquisition &
Acquisition and management of resources, whether computing or instrumentation,
required for the successful execution of the workflow. \tabularnewline\hline
Task management & Primary subsystem for managing individual activities, tasks or
``subworkflow'' using resources provided by the task management system. This
system is sometimes, but neither often nor exclusively, part of the workflow
execution engine. \tabularnewline\hline 
Provenance engine & System for tracking
execution history, sources, and destinations of ingested and generated artifacts,
execution metadata including status, general logging, and provenance-based
inference tools. \tabularnewline\hline 
Application programming interface (API) &
A non-functional element of most workflow management systems that is critical to
successful deployment and maintenance of the full system as well as use
as a tool for creating and executing workflows. \tabularnewline\hline
\end{tabu} 
\caption{Functionality commonly identified in workflow management
systems.} 
\label{blocks}
\end{table*}

Each of the types of functionality listed in Table
\ref{blocks} could be developed, presumably through one or more community
efforts, as a building block (even the API through some programming
trickery!). Other things like programming interfaces to queuing systems,
programmable pilot systems for scheduling jobs, workload balancers, and
ensemble execution tools, among others, could be provided as well to create a
rich ecosystem of reusable and interchangeable parts.

Reusable building blocks would greatly improve both interoperability and
sustainability because they would standardize, to some degree, the programming
interfaces and back-ends used by workflow management systems. To the extent that
projects are willing to use common building blocks, proliferation would be fully
decoupled from interoperability. Leadership computing facilities would not need
to support every workflow management system, just a set of common building
blocks. This is similar to how they support third-party libraries for software
development: they do not support every code used on these machines, but
they support a set of common libraries that the codes can use. 

There is an important practical question here: Does this mean abandoning
existing workflow management systems or redeveloping existing workflows? No, and
in fact it may be quite practical to develop building blocks based on components
of the most sophisticated workflow management systems already in existence.
Furthermore, because building blocks would naturally enable interoperability, it
is quite conceivable that a workflow that only executes on one system now may
execute on many systems in the future with little or no modification. 

A second question is whether or not building blocks represent a significantly new
type of modularity versus a traditional software stack or framework. Building blocks
arguably sit above these entities and have distinct conceptual and functional roles.
A software stack is the full set of software, including all dependencies, for a given
application or software product and a framework is the set of common functionality
(APIs, not libraries) around which the product is built. On the other hand, a
building block may be implemented using a framework and will have some software stack,
but it will also offer a complete set of functionality that can be used directly in
an application. The building block may also be offered on a different system with a
different implementation (i.e., using a different software stack and framework), but neither its functionality nor service interface would change.