\section{Introduction}

Suppose for a moment that there is an interesting activity that would benefit
from automation, which is known because the activity exhibits the following
properties: 
\begin{itemize} 
\item The goal of the activity is known and desirable.  
\item The tasks to achieve the goal and complete the activity are also known 
and, furthermore, highly repetitive even in cases where decisions must be 
made to continue.  
\item The results of achieving this goal can be consumed or processed in 
standard ways.  
\end{itemize}

This example may be recognized by many as a description - but not a definition -
of a \textit{workflow}. Experts from many different backgrounds can easily think
of activities that fit this description and even systems that automate the
activity. However, each expert will probably also imagine a different workflow:
a businessperson might imagine the workflow for processing payments, a medical
professional might imagine it to be updating medical charts and records, and
scientists might imagine performing an analysis with modeling and simulation
software, analyzing a large amount of data, or quantifying uncertainty. Within
the scientific community this has led to a rather predictable situation:
Everyone has a different definition of ``workflow'' and has created their own
systems for managing and processing workflows.

This leads to some very practical consequences for \textit{scientific
workflows}. In spite of the similarities in high-level abstractions and
higher-order concepts, extremely specialized software solutions and communities
have developed to process scientific workflows. These differences hold across
scientific problems, all generally providing some level of service that was not
or perhaps is not available in a regular programming language, system library,
or problem solving workbench. These systems have accreted workflow management
capabilities over time that have effectively resulted in the creation of large,
monolithic software stacks that cannot communicate between each other, require a
very large amount of expertise to use, often put very high demands on back-end
systems either by design or through assumptions, and are often too specialized
to jump between workflow execution for data analysis and modeling and
simulation. 

Recent developments suggest that this may be neither desirable nor necessary.
Specifically, as scientific problems become more complex, functionality moves
from libraries into operating systems, and open source development continues to
rise as the dominant means of collaborating on software development activities,
the scalability, sophistication, and maintainability of large monolithic systems
raise significant questions. Software complexity, in particular, often makes it
impossible for development on large systems to scale to the required level 
because the accretion of new capability means managing larger pools of
people and a larger software development effort. One obvious alternative with
some degree of historical precedence in the field is to develop \textit{common
building blocks} that provide common services used to both define and execute
workflows. Such an approach not only makes it possible to coalesce around a
standard definition and understanding of workflows, but to separate and
distribute the work required to construct the building blocks from the effort to
define workflows and to create workflow management systems that may share the
building blocks while retaining required customizations. This article
contributes to the on-going discussion by providing the following:
\begin{itemize} \item We provide an illustration of the diverse nature of
scientific workflows, (see \S \ref{workflows}), that describes the different
areas where scientific workflows and systems have appeared in the literature,
how they have been classified in the past, and the arguments around coalescence
that are driven by calls of interoperability.  \item We describe a necessary
subset of functionality that is common across a number of scientific workflow
management systems which would, in principle, be good candidates for
consolidation and sharing, (see \S \ref{commonFunc}).\todo{"F your language! I
want C/Python/something!" What to say?} \item We develop an understanding of
these common elements as building blocks and how composing these building blocks
addresses a number of the problems not easily addressed by the monolithic design
of existing systems, see \S \ref{buildings-blocks}).\todo{One good example: How
to run Pegasus or BigPanda on Titan? Not easy, but would be easier with the
right building block.} \end{itemize}

